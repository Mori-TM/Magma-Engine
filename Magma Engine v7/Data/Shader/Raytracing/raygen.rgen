#version 460
#extension GL_EXT_ray_tracing : enable

layout(binding = 0, set = 0) uniform accelerationStructureEXT TopLevelAS;
layout(binding = 1, set = 0, rgba8) uniform image2D Image;
layout(binding = 2, set = 0) uniform UniformBufferObject 
{
	mat4 ViewInverse;
	mat4 ProjInverse;
	vec4 LightDir;
	uint Time;
} UBO;

struct PayLoad
{
	vec3 HitValue;
	float Distance;
	vec3 Normal;
	float Reflector;
	uint Index;
	bool WasInShadow;
	uint Time;
};

layout(location = 0) rayPayloadEXT PayLoad HitValue;

void main() 
{
	const vec2 PixelCenter = vec2(gl_LaunchIDEXT.xy) + vec2(0.5);
	const vec2 InUV = PixelCenter / vec2(gl_LaunchSizeEXT.xy);
	vec2 d = InUV * 2.0 - 1.0;

	vec4 Origin = UBO.ViewInverse * vec4(0, 0, 0, 1);
	vec4 Target = UBO.ProjInverse * vec4(d.x, d.y, 1, 1) ;
	vec4 Direction = UBO.ViewInverse * vec4(normalize(Target.xyz), 0);

	float MinT = 0.001;
	float MaxT = 1000.0;

	HitValue.HitValue = vec3(1.0);
	HitValue.Time = UBO.Time;

	vec3 color = vec3(0.0);
	int Iterations = 1;
	HitValue.WasInShadow = false;

	for (int i = 0; i < 4; i++) {
	HitValue.Index = i;
		traceRayEXT(TopLevelAS, gl_RayFlagsOpaqueEXT, 0xff, 0, 0, 0, Origin.xyz, MinT, Direction.xyz, MaxT, 0);
		vec3 hitColor = HitValue.HitValue;

		if (HitValue.Reflector < 0.0f) 
		{
			color += hitColor;
			break;

			
		} 
		else 
		{
			const vec4 hitPos = Origin + Direction * HitValue.Distance;
			Origin.xyz = hitPos.xyz + HitValue.Normal * 0.001f;
			Direction.xyz = reflect(Direction.xyz, HitValue.Normal);
			color += hitColor;
			Iterations++;
			if (HitValue.Reflector < 0.0)
				break;
		}

	//	if (HitValue.Distance < 0.0f) {
	//		color += hitColor;
	//		break;
	//	} else if (HitValue.Reflector >= 0.1f) {
	//		const vec4 hitPos = Origin + Direction * HitValue.Distance;
	//		Origin.xyz = hitPos.xyz + HitValue.Normal * 0.001f;
	//		Direction.xyz = reflect(Direction.xyz, HitValue.Normal);
	//	} else {
	//		color += hitColor;
	//		break;
	//	}

	}

//    traceRayEXT(TopLevelAS, gl_RayFlagsOpaqueEXT, 0xff, 0, 0, 0, Origin.xyz, MinT, Direction.xyz, MaxT, 0);
	
	if (Iterations > 1)
		Iterations--;

	imageStore(Image, ivec2(gl_LaunchIDEXT.xy), vec4(color / Iterations, 0.0));
}
